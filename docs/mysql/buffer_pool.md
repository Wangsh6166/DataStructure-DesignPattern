### 缓存的重要性-Buffer Pool

在`innodb`引擎当中，数据和索引都是以页的形式存在表空间当中，表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象。所以数据最终还是存在磁盘上面，为了匹配上cpu的处理速递，InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。

#### Innodb 中 Buffer Pool

innoDB为了缓存磁盘中的页，在MySQL服务器启动的时候就向操作系统申请了一片连续的内存，叫做Buffer Pool（名是缓冲池)。

默认情况下Buffer Pool只有`128M`大小。可以在启动服务器的时候配置`innodb_buffer_pool_size`参数的值，它表示Buffer Pool的大小:
```
[server]
innodb_buffer_pool_size = 1024000000
```

#### Buffer Pool 内部组成

Buffer Pool中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是16KB。为了更好的管理这些在Buffer Pool中的缓存页，InnoDB为每一个缓存页都创建了一些所谓的控制信息，这些控制信息包括该页所属的表空间编号、页号、缓存页在Buffer Pool中的地址、链表节点信息、一些锁信息以及LSN信息，还有一些别的控制信息。

每个缓存页对应的控制信息占用的内存大小是相同的，我们就把每个页对应的控制信息占用的一块内存称为一个控制块，控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边，所以整个Buffer Pool对应的内存空间看起来就是这样的：

![](../../images/mysql/buffer-pool.png)


可以看到控制块和缓存页之间有一个碎片,每一个控制块都对应一个缓存页，那在分配足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小，这个用不到的那点儿内存空间就被称为碎片了。当然，如果把Buffer Pool的大小设置的刚刚好的话，也可能不会产生碎片

> 备注：每个控制块大约占用缓存页大小的5%，在MySQL5.7.21这个版本中，每个控制块占用的大小是808字节。而我们设置的innodb_buffer_pool_size并不包含这部分控制块占用的内存空间大小，也就是说InnoDB在为Buffer Pool向操作系统申请连续的内存空间时，这片连续的内存空间一般会比innodb_buffer_pool_size的值大5%左右。

#### free链表

最初启动Mysql服务器的时候，向操作系统申请到了`Buffer Pool`的内存空间，然后把它分为若干个控制块和缓存页。然后随着程序的运行，不断的有磁盘上的页被缓存到Buffer Pool中，这时为了区分`Buffer Pool`中空闲的缓存页，缓存页对应的控制块就起了作用。
innodb把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表就称为`free 链表`。

有了`free 链表`之后，每当需要从磁盘中加载一个页到Buffer Pool中时，就从free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上（就是该页所在的表空间、页号之类的信息），然后把该缓存页对应的free链表节点从链表中移除，表示该缓存页已经被使用了

#### flush链表的管理

如果我们修改了Buffer Pool中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为`脏页`。

如果我们一做出修改就同步到磁盘上，这样性能就很低。所以每次修改缓存页后，不会立即同步，而是在未来某个时间点进行同步。

但是如果不立即同步到磁盘的话，那之后再同步的时候我们怎么知道Buffer Pool中哪些页是脏页，哪些页从来没被修改过呢？所以，innodb会创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫`flush链表`。


#### LRU链表的管理

`Buffer Pool`内存容量有限，所以使用创建来一个`LRU链表`来淘汰旧的缓存页，释放空间。

具体的LRU策略并不是简单的LRU，具体的情况需要查阅相关资料


#### 刷新脏页到磁盘

后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。主要有两种刷新路径：


- 从LRU链表中刷新一部分页面到磁盘：

后台线程会定时从LRU链表尾部开始扫描一些页面，扫描的页面数量可以通过系统变量`innodb_lru_scan_depth`来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称之为`BUF_FLUSH_LRU`

- 从flush链表中刷新一部分页面到磁盘：

后台线程也会定时从flush链表中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为`BUF_FLUSH_LIST`。

